# 秒杀项目

## 技术栈

使用SpringBoot + Mybatis + jQuery + MySQL完成基本的秒杀功能。
Nginx用于反向代理服务器，Redis用于存储登陆信息、热点数据存储等，RocketMQ用于异步消息推送。

## 项目简介

采用前后端分离的开发模式，前端使用ajax完成请求的获取，后端通过SpringMVC完成请求的接收及处理。同时配置session跨域授信请求。
项目分成VO层、Model层和DO层。
其中VO层是前端页面展示的对象，Model层用于主要的业务处理，DO层对应数据库的对象。

### 分布式扩展
- 加入nginx做动静分离服务器和反向代理服务器进行负载均衡。
- 分布式会话管理方面，使用redis存储登陆凭证token。

### 缓存设计
使用多级缓存机制
- redis用作三级缓存，除了存储热点商品信息外，还可以存储用户登陆信息，商品校验信息等。
- 本地热点缓存用于二级缓存，使用Google的Guava Cache用于存储热点浏览数据。
- 最靠近用户的地方再添加一级缓存，使用nginx的lua缓存机制。热点数据存储到lua缓存中，同时对于非热点但是高流量的数据，直接配置成从redis取。

### 数据一致性
主要是商品库存的数据一致性问题。在redis中减完库存后，使用异步消息队列RocketMQ完成异步化的方式同步数据库数据。
消息生产方定义同步库存扣减消息，投递给broker中对应的topic，之后消息消费放实现真正的到数据库内扣减的操作。

### 流量削峰
- 秒杀令牌。获取秒杀接口前需要先获得秒杀令牌才行，秒杀令牌会对秒杀活动信息、商品信息和用户信息进行校验，防止恶意脚本无限制调用秒杀接口。
- 秒杀大闸。获得秒杀令牌前需要先通过“大闸”才行，根据秒杀商品初始库存颁发对应数量令牌，控制大闸流量。
- 队列泄洪。在进入秒杀接口前，可以使用队列泄洪机制控制同一时刻调用接口的线程数，使接口的压力减到最小。

### 防刷限流
- 使用验证码技术包装秒杀令牌前置，即用户在获取秒杀令牌前，需要通过验证码验证，达到请求错峰的目的
- 使用令牌桶算法进行限流，限制每秒获取令牌的数量
- 防刷技术可以通过控制某个ip在一定时间内的调用次数，或者更高级的防刷技术，这里略。

流量削峰 + 防刷限流的效果：
验证码校验——>秒杀大闸数量校验——>获取秒杀令牌——>令牌桶算法取令牌——>队列泄洪——>接口调用。 

## 数据库设计
用户相关：`user_info`为用户信息表，`user_password`为用户密码表。
商品相关：`item`为商品信息表，此外，还有个`item_stock`用来保存对应商品的库存。考虑到库存表会经常变动，所以将其单独分离出来。
订单相关：`order_info`为主要的订单信息表。订单号不是简单的主键递增方式，而是另外起了一张`sequence_info`表，程序中通过该表种的字段值
完成订单号的计算。此外，`promo`为秒杀活动表。订单信息表种的每件商品都和相应的秒杀活动id对应，如果没有秒杀活动则取默认值0。